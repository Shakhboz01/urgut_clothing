c
с
c
@delivery_from_counterparties_in_usd
@expenditures_in_usd
@sales_in_usd
@overall_income_in_usd
c
sales.where('sales.price_in_usd = ?', true).sum(:total_paid) *100
sales.where('sales.price_in_usd = ?', true)
unpaid_difference_in_percent_in_usd
c
unpaid_difference_in_percent_in_uzs
unpaid_difference_in_percent_in_usd
c
sales.where('sales.price_in_usd = ?', true).sum(:total_price)
sales.where('sales.price_in_usd = ?', true).sum(:total_paid) * 100
sales.where('sales.price_in_usd = ?', true).sum(:total_paid) * 100 / sales.where('sales.price_in_usd = ?', true).sum(:total_price)
unpaid_difference_in_percent_in_usd
product_sells.price_in_usd.sum(:total_profit)
unpaid_difference_in_percent_in_usd >= 100
unpaid_difference_in_percent_in_uzs >= 100
@profit_from_sale_in_usd
c
difference.positive?
difference
c
initial_remaining
self.decrement!(:initial_remaining, difference.abs)
difference.abs
initial_remaining
c
Pack.last.initial_remaining
self.increment!(:initial_remaining, difference.abs)
difference.abs
difference.to_i
c
initial_remaining_was
initial_remaining
self.calculate_product_remaining
c
can_restore.valid?
c
can_restore.valid?
c
can_restore.valid?
c
can_restore
can_restore.valid?
packs_number_to_restore
c
packs_number_to_restore
c
can_restore.valid?
c
          psc = pack.product_size_colors.find_by_size_id(product.size_id)
psc = pack.product_size_colors
pack.product_size_colors.pluck(:size_id)
product.size_id
psc
c
ps
ps.result
ps.errors.messages
c
ps.errors.messages
c
amount
ps.errors.messages
ps.valid?
c
amount_of_pack_to_break.to_i
self
c
product_sell_params[:sell_by_piece]
c
sell_by_piece
c
result[:average_prices]
sell_by_piece
c
sell_by_piece
c
!product_sell_params[:sell_by_piece].to_i.zero?
c
sell_by_piece
c
product_sell_params[:sell_by_piece].to_i.zero?
c
product_sell_params[:sell_by_piece].to_i.zero?
c
product_sell_params[:sell_by_piece].to_i.zero?
c
product_sell_params[:sell_by_piece]
c
p.errors.messages
p=    Product.create(name: pack.name, size: size, color: color, barcode: pack.barcode, pack: pack)
   13:       name: pack.name, size: size, color: color, barcode: pack.barcode, pack: pack
    Product.create(name: pack.name, size: size, color: color, barcode: pack.barcode, pack: pack)
size
pack.name
c
pack_params['delivery_id']
c
price_in_usd
sell_price
c
rate
sell_price.to_i
c
price_in_usd == price_in_usd_was
c
ProductEntry.last
ProductEntry.where(id:'16')
data[0]
ProductEntry.find_by("16")
c
price_in_usd
average_prices["average_buy_price_in_uzs"]
price_in_usd
sell_price
c
ProductSell.last
price_data
c
data[1]["amount"]
data[0]
data[1]["amount"]
c
amount <= pack.initial_remaining
c
product_sell.sell_price
price_in_usd
sell_price
c
sell_price
c
sell_price
c
sell_price.to_i
c
sell_price
c
price_in_usd_was
c
sell_price
price_in_usd
c
price_data
average_prices
c
!new_record?
self.persisted?
c
average_prices
c
sell_price_in_uzs
self.total_profit
c
sell_price_in_uzs
buy_price_in_uzs
buy_price_in_usd
sell_price_in_usd
c
average_sell_price_in_usd
c
price_in_usd
average_sell_price_in_usd
c
price_data
average_sell_price_in_uzs
average_buy_price_in_uzs
average_buy_price_in_usd
average_sell_price_in_usd
c
set_prices_in_usd
rate
price_data.to_h
c
price_data.to_h
c
set_prices_in_usd
price_data.to_h
c
price_data.to_h
a
a.result
      a=ProductSells::FindAverageSellAndBuyPrice.run!(price_data: price_data.to_h, rate: rate, price_in_usd: set_prices_in_usd)
set_prices_in_usd
price_data.to_h
c
price_data.to_h
c
price_data.to_h
c
price_data.to_h
c
set_prices_in_usd != product_entry.paid_in_usd
set_prices_in_usd
c
price_data.to_h
c
ProductEntry.find(13)
amount
product_entry_ids
c
unsold_product_entries
amount
pack
c
response.result
c
pack
        response = ProductSells::FindProductEntriesUntilAmount.run!(product: pack,          amount: amount)
pack.class
c
first_available_entry
pack.initial_remaining <= 0 && !first_available_entry.nil?
!first_available_entry.nil?
pack.initial_remaining
c
pack
c
response.result[:average_prices][:average_buy_price_in_uzs].to_i/12000
CurrencyRate.last.rate
response.result
c
response.result
c
response.result
c
response.errors.messages
response.result
c
@filtered_packs
c
Pack.last
c
@product.errors.messages
c
dog_attributes.values.any?(&:empty?)
dog_attributes.keys
c
dog_attributes.values.any?(&:empty?)
dog_attributes
c
dog_attributes
c
dog_attributes
c
dog_attributes
dog_attributes[:size_id] = 3
dog_attributes
c
params.require(:pack)
 params.require(:pack).permit(:name)
